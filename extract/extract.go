// Package extract provides a set of routines for extracting various Byte
// "entities" from text
//
// This package supports extraction of Byte usernames, hashtags, and URLs.
package extract

import (
	"fmt"
	"sort"
	"strings"
	"unicode/utf8"
)

// Range is used  to specify offsets in a string where entities are located
type Range struct {
	Start int
	Stop  int
}

// Length returns the length of the range
func (r *Range) Length() int {
	return r.Stop - r.Start
}

// String implements the Stringer interface
func (r Range) String() string {
	return fmt.Sprintf("(%d, %d)", r.Start, r.Stop)
}

// EntityType specifies the type of a given entity
type EntityType int

// EntityTypes
const (
	Mention EntityType = iota
	Hashtag
	URL
)

// String implements the Stringer interface
func (t EntityType) String() string {
	switch t {
	case Mention:
		return "Mention"
	case Hashtag:
		return "Hashtag"
	case URL:
		return "URL"
	}
	return "Unknown"
}

// ByteEntity is the structure representing an "entity" within a string.
type ByteEntity struct {
	Text      string // The value of the entity
	Range     Range  // Represents the location of the entity in character/rune offsets
	ByteRange Range  // Represents the location of the entity in byte offsets
	Type      EntityType

	screenName string // Contains the value of username without the leading '@' when Type=Mention
	hashtag    string // Contains the value of the hashtag without the leading # when Type=Hashtag

	screenNameIsSet bool
	hashtagIsSet    bool
}

type entitiesT []*ByteEntity

// The indices generated by the various extract functions are
// byte offsets. This function calculates charecter/rune offsets
// based on those offsets
func (e entitiesT) fixIndices(text string) {
	for _, entity := range e {
		start := utf8.RuneCountInString(text[:entity.ByteRange.Start])
		entity.Range.Start = start
		stop := utf8.RuneCountInString(entity.Text)
		entity.Range.Stop = start + stop
	}
}

func (e *entitiesT) removeOverlappingEntities() {
	if e.Len() < 2 {
		return
	}

	var (
		result   []*ByteEntity
		prev     *ByteEntity
		cur      *ByteEntity
		entities = *e
	)
	prev = entities[0]
	result = append(result, prev)
	for _, cur = range entities[1:] {
		if !(prev.Range.Stop > cur.Range.Start) {
			result = append(result, cur)
		}
		prev = cur
	}
	*e = result
}

func (e entitiesT) Len() int {
	return len(e)
}

func (e entitiesT) Less(i, j int) bool {
	return e[i].Range.Start < e[j].Range.Start
}

func (e entitiesT) Swap(i, j int) {
	e[i], e[j] = e[j], e[i]
}

// Implement the Stringer interface
func (t *ByteEntity) String() string {
	return fmt.Sprintf("ByteEntity{Text: [%s] Range: %+v Type: %v", t.Text, t.Range, t.Type)
}

// ScreenName returns the value of the extracted screen name
// (when Type=Mention) and a boolean indicating whether the value is set. The
// return value will be ("", false) when Type != Mention
func (t *ByteEntity) ScreenName() (string, bool) {
	return t.screenName, t.screenNameIsSet
}

// Hashtag Returns the value of the extracted hashtag (when Type=Hashtag) and
// a boolean indicating whether the value is set. The return value will be
// ("", false) when Type != Hashtag
func (t *ByteEntity) Hashtag() (string, bool) {
	return t.hashtag, t.hashtagIsSet
}

// Entities extracts all usernames and hashtags from the given text -
// returned in the order they appear within the input string
func Entities(text string) []*ByteEntity {
	var result entitiesT
	result = URLs(text)
	result = append(result, Hashtags(text)...)
	result = append(result, Mentions(text)...)

	sort.Sort(result)
	result.removeOverlappingEntities()
	return result
}

// URLs extracts urls from the given text. Returns a slice of ByteEntity struct
// pointers.
func URLs(text string) []*ByteEntity {
	// This giant pile of barf is copied from the various twitter-text
	// implementations. There must be a better way!
	var result entitiesT
	var (
		matchStart     int
		matchEnd       int
		precedingStart int
		precedingEnd   int
		domainStart    int
		domainEnd      int
		pathStart      int
		pathEnd        int
	)

	// Start at the beginning of the input string, walking forward one match at
	// a time. We have to walk the string because the regexp package lacks
	// support for lookahead assertions
	offset := 0
	nextOffset := 0
	for {
		offset = nextOffset
		substr := text[offset:]
		match := validURL.FindStringSubmatchIndex(substr)

		// If no matches are found in this portion of the string, we're done
		if match == nil {
			break
		}

		// Next time around, start at the end of the current match, minus 1
		// because indices are not inclusive
		nextOffset = match[1] + offset - 1

		matchStart = match[validURLGroupURL*2]
		matchEnd = match[validURLGroupURL*2+1]

		// If protocol is missing, only extract ascii domains
		if match[validURLGroupProtocol*2] < 0 {
			var lastEntity *ByteEntity
			lastInvalid := false
			precedingStart = match[validURLGroupBefore*2]
			precedingEnd = match[validURLGroupBefore*2+1]
			domainStart = match[validURLGroupDomain*2]
			domainEnd = match[validURLGroupDomain*2+1]
			pathStart = match[validURLGroupPath*2]
			pathEnd = match[validURLGroupPath*2+1]

			// check for invalid preceding character
			if invalidURLWithoutProtocolMatchBegin.MatchString(
				substr[precedingStart:precedingEnd],
			) {
				continue
			}

			// Make sure the protocol-less domain is ascii only
			// e.g., in the case of "한국twitter.com", only extract twitter.com
			if m := validASCIIDomain.FindStringSubmatchIndex(
				substr[domainStart:domainEnd],
			); m != nil {
				lastEntity = &ByteEntity{
					Text: substr[matchStart+m[0] : matchStart+m[1]],
					ByteRange: Range{
						Start: matchStart + offset + m[0],
						Stop:  matchStart + offset + m[1]},
					Type: URL}

				// Set the next offset to the end of this match
				nextOffset = matchStart + m[1] + offset - 1

				// If the url has a Generic TLD (not CC TLD), it's valid
				if lastInvalid = invalidShortDomain.MatchString(
					lastEntity.Text,
				); !lastInvalid {
					result = append(result, lastEntity)
				}
			}

			if lastEntity == nil {
				continue
			}

			// If the match contains a path immediately following the domain,
			// append it to the match
			if pathStart > 0 && pathStart == lastEntity.ByteRange.Stop-offset {
				// If the last result was invalid b/c it did not contain a GTLD,
				// append it
				if lastInvalid {
					result = append(result, lastEntity)
				}

				// Update the text and offsets
				lastEntity.Text += substr[pathStart:pathEnd]
				lastEntity.ByteRange.Stop = pathEnd + offset
				nextOffset = lastEntity.ByteRange.Stop - 1
			} else if validSpecialShortDomain.MatchString(lastEntity.Text) {
				result = append(result, lastEntity)
			}
		} else {
			// Else, the url contains a protocol
			url := substr[matchStart:matchEnd]
			// If it's a t.co url, restrict to certain path characters
			if tcoLoc := validTcoURL.FindStringIndex(url); tcoLoc != nil {
				url = url[tcoLoc[0]:tcoLoc[1]]
				matchEnd = matchStart + len(url)
			}
			result = append(result,
				&ByteEntity{Text: url,
					ByteRange: Range{
						Start: matchStart + offset,
						Stop:  matchEnd + offset},
					Type: URL})
		}
	}

	// Add character/rune offsets in addition to byte offsets
	result.fixIndices(text)
	return result
}

// MentionedScreenNames extracts @username mentions from the supplied text.
// Returns a slice of ByteEntity struct pointers.
// The ScreenName field in the returned structs will contain the value of the
// referenced username without the leading @ sign
func MentionedScreenNames(text string) []*ByteEntity {
	mentions := Mentions(text)
	var result []*ByteEntity
	for _, e := range mentions {
		result = append(result, e)
	}
	return result
}

// Mentions extracts @username mentions from the supplied text. Returns a slice
// of ByteEntity struct pointers.
// The ScreenName field in the returned structs will contain the value of the
// referenced username without the leading @ sign.
func Mentions(text string) []*ByteEntity {
	// Optimization
	if !strings.ContainsAny(text, "@＠") {
		return nil
	}

	var result entitiesT
	matches := validMention.FindAllStringSubmatchIndex(text, -1)
	for _, m := range matches {
		matchEnd := text[m[1]:]
		if invalidMentionMatchEnd.MatchString(matchEnd) {
			continue
		}

		atSignStart := m[validMentionGroupAt*2]
		screennameStart := m[validMentionGroupUsername*2]
		screennameEnd := m[validMentionGroupUsername*2+1]

		if screennameEnd-screennameStart < 3 || screennameEnd-screennameStart > 20 {
			continue
		}

		start := atSignStart
		stop := screennameEnd

		result = append(result, &ByteEntity{
			Text:            text[start:stop],
			screenName:      text[screennameStart:screennameEnd],
			screenNameIsSet: true,
			ByteRange: Range{
				Start: start,
				Stop:  stop,
			},
			Type: Mention,
		})
	}

	result.fixIndices(text)
	return result
}

// Hashtags extracts #hashtag occurrences from the supplied text. Returns a
// slice of ByteEntity struct pointers.
// The Hashtag field of the returned entities will contain the value of the
// extracted hashtag without the leading # character
func Hashtags(text string) []*ByteEntity {
	return extractHashtags(text, true)
}

func extractHashtags(text string, checkURLOverlap bool) []*ByteEntity {
	// Optimization
	if !strings.ContainsAny(text, "#＃") {
		return nil
	}
	var result entitiesT
	var hashStart int
	var hashtagStart int
	var hashtagEnd int
	for _, match := range validHashtag.FindAllStringSubmatchIndex(text, -1) {
		if invalidHashtagMatchEnd.MatchString(text[match[1]:]) {
			continue
		}
		hashStart = match[validHashtagGroupHash*2]
		hashtagStart = match[validHashtagGroupTag*2]
		hashtagEnd = match[validHashtagGroupTag*2+1]
		result = append(result, &ByteEntity{
			Text:         text[hashStart:hashtagEnd],
			hashtag:      text[hashtagStart:hashtagEnd],
			hashtagIsSet: true,
			ByteRange: Range{
				Start: hashStart,
				Stop:  hashtagEnd,
			},
			Type: Hashtag,
		})
	}

	result.fixIndices(text)

	if checkURLOverlap {
		urls := URLs(text)
		result = append(result, urls...)
		sort.Sort(result)
		result.removeOverlappingEntities()

		numHashtags := 0
		for _, e := range result {
			if e.Type == Hashtag {
				result[numHashtags] = e
				numHashtags++
			}
		}
		result = result[:numHashtags]

		var tmpResult []*ByteEntity
		for _, e := range result {
			if e.Type == Hashtag {
				tmpResult = append(tmpResult, e)
			}
		}
		result = tmpResult
	}

	return result
}
